{"version":3,"file":"map.m.js","sources":["../src/map.js"],"sourcesContent":["/**\n * Plugin to add .map() to handle sync and async map predicate\n * @param {function} node\n */\nexport default function mapPlugin (node) {\n  /**\n   * Each change in node's value will trigger a call to fn passing the current\n   * value unless fn is awaiting a promise. If fn is async, the current value\n   * of node is compared to the last call to fn triggering an update if the\n   * values differ.\n   *\n   * If err is not passed, a rejected promise will send its value to result.\n   * @param {function} fn calculates the next value based on value changes of node\n   * @param {function} [err] optional callback or node\n   * @returns {function} result node with the same context as `node`\n   * @example\n   *  var a = state('a')\n   *  var b = a.map(() => <Promise>) // b will have a resolve/reject value, not <Promise>\n   *  var c = b.map(() => ...) // c reacts synchronously to changes of b\n   */\n  node.map = (fn, err) => {\n    const result = node.state()\n    const cache = (result.locals.map = { value: undefined, awating: false })\n    const update = next => {\n      result.sealed = false\n      result(next)\n      result.seal()\n    }\n    function fastForward () {\n      if (node.value !== cache.value) {\n        listener(node.value)\n      }\n    }\n    function resolve (next) {\n      cache.awaiting = false\n      update(next)\n      fastForward()\n    }\n    function reject (next) {\n      cache.awaiting = false\n      err(next)\n      fastForward()\n    }\n    function listener (value) {\n      if (cache.awaiting) return\n      cache.value = value\n      const next = fn(value)\n      if (isPromise(next)) {\n        cache.awaiting = true\n        next.then(resolve).catch(err ? reject : resolve)\n      } else {\n        update(next)\n      }\n    }\n    result.cancel = node.on(listener)\n    result.seal()\n    fastForward()\n    return result\n  }\n}\n\nfunction isPromise (obj) {\n  return !!obj && typeof obj.then === 'function'\n}\n"],"names":["node","map","fn","err","const","result","state","cache","locals","value","undefined","awating","update","next","sealed","seal","fastForward","listener","resolve","awaiting","reject","obj","then","catch","cancel","on"],"mappings":"eAIe,SAAoBA,GAgBjCA,EAAKC,aAAOC,EAAIC,GACdC,IAAMC,EAASL,EAAKM,QACdC,EAASF,EAAOG,OAAOP,KAAQQ,WAAOC,EAAWC,SAAS,GAC1DC,WAASC,GACbR,EAAOS,QAAS,EAChBT,EAAOQ,GACPR,EAAOU,QAET,SAASC,IACHhB,EAAKS,QAAUF,EAAME,OACvBQ,EAASjB,EAAKS,OAGlB,SAASS,EAASL,GAChBN,EAAMY,UAAW,EACjBP,EAAOC,GACPG,IAEF,SAASI,EAAQP,GACfN,EAAMY,UAAW,EACjBhB,EAAIU,GACJG,IAEF,SAASC,EAAUR,GACjB,IAAIF,EAAMY,SAAV,CACAZ,EAAME,MAAQA,EACdL,IAeciB,EAfRR,EAAOX,EAAGO,IAeFY,EAdAR,IAekB,mBAAbQ,EAAIC,MAdrBf,EAAMY,UAAW,EACjBN,EAAKS,KAAKJ,GAASK,MAAMpB,EAAMiB,EAASF,IAExCN,EAAOC,IAMX,OAHAR,EAAOmB,OAASxB,EAAKyB,GAAGR,GACxBZ,EAAOU,OACPC,IACOX"}